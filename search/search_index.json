{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\n\n\nOpenRISC is a CPU architecture developed by the OpenCores community. OR1200 is an open-source Verilog implementation of the CPU core, and ORPSoC (OpenRISC Reference Platform System on Chip) combines the OR1200 CPU with a set of peripherals.\n\n\n\n\nToolchain on the Linux\n\n\nDependencies\n\n\nsudo apt-get install libmpc-dev libgmp3-dev libmpfr-dev lzop libsdl1.2-dev xterm automake libtool\n\n\n\nOpenRISC GNU tool chain precompiled for 32-bit Linux\n\n\nor1k-elf- toolchain built in April 2013 from github sources (150MB)\n\n\nExtract this under /opt to create the directory or1k-toolchain.\n\n\nThen run the following to add the executables to your $PATH:\n\n\necho \"# OpenRISC tool chain path\" >> ~/.bashrc\n\necho \"export PATH=$PATH:/opt/or1k-toolchain/bin\" >> ~/.bashrc\n\n\n\n0. Stack\n\n\n \n\n\n0.1 Stack structure\n\n\n\u251c\u2500\u2500\u2500alexa\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500arch\n\u251c\u2500\u2500\u2500asio\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500audio_player\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500bear_ssl\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u251c\u2500\u2500\u2500src\n\u2502   \u2514\u2500\u2500\u2500tools\n\u251c\u2500\u2500\u2500cjson\n\u2502   \u2514\u2500\u2500\u2500inc\n\u251c\u2500\u2500\u2500common\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500dlna\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500drivers\n\u251c\u2500\u2500\u2500fifo\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500http\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500httpclient\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u2514\u2500\u2500\u2500src\n\u251c\u2500\u2500\u2500lwip\n\u2502   \u251c\u2500\u2500\u2500contrib\n\u2502   \u2502   \u2514\u2500\u2500\u2500port\n\u2502   \u2502       \u2514\u2500\u2500\u2500FreeRTOS\n\u2502   \u2502           \u2514\u2500\u2500\u2500OpenRISC\n\u2502   \u2502               \u2514\u2500\u2500\u2500arch\n\u2502   \u251c\u2500\u2500\u2500doc\n\u2502   \u2514\u2500\u2500\u2500src\n\u2502       \u251c\u2500\u2500\u2500api\n\u2502       \u251c\u2500\u2500\u2500core\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2514\u2500\u2500\u2500snmp\n\u2502       \u251c\u2500\u2500\u2500include\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500lwip\n\u2502       \u2502   \u2514\u2500\u2500\u2500netif\n\u2502       \u2514\u2500\u2500\u2500netif\n\u2502           \u2514\u2500\u2500\u2500ppp\n\u251c\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2502   \u2514\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500library\n\u2502   \u2514\u2500\u2500\u2500port\n\u251c\u2500\u2500\u2500mqtt\n\u2502   \u251c\u2500\u2500\u2500MQTTClient-C\n\u2502   \u2502   \u251c\u2500\u2500\u2500samples\n\u2502   \u2502   \u2502   \u2514\u2500\u2500\u2500linux\n\u2502   \u2502   \u2514\u2500\u2500\u2500src\n\u2502   \u2502       \n\u2502   \u2514\u2500\u2500\u2500MQTTPacket\n\u2502       \u251c\u2500\u2500\u2500samples\n\u2502       \u251c\u2500\u2500\u2500src\n\u2502       \u2514\u2500\u2500\u2500test\n\u251c\u2500\u2500\u2500multipart_parser\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500nghttp2\n\u2502   \u251c\u2500\u2500\u2500lib\n\u2502   \u2502   \u2514\u2500\u2500\u2500includes\n\u2502   \u2502       \u2514\u2500\u2500\u2500nghttp2\n\u2502   \u2514\u2500\u2500\u2500port\n\u2502       \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500nghttp_client\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500sntp\n\u2502   \u2514\u2500\u2500\u2500inc\n\u251c\u2500\u2500\u2500Source  \n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2514\u2500\u2500\u2500portable\n\u2514\u2500\u2500\u2500url_parser\n    \u2514\u2500\u2500\u2500include\n\n\n\n1. RTOS: FreeRTOS\n\n\n\u251c\u2500\u2500\u2500Source  \n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2514\u2500\u2500\u2500portable\n\n\n\n\n\nFreeRTOS is a real-time OS that manages a multitasking and multiprocessing \nsystem environment. It has a scheduler to manage user created tasks.\nFreeRTOS provides APIs for users to control, \nsynchronize and communicate among various tasks.\n\n\n\n\n1.1. Features\n\n\nFreeRTOS supports the following five features to accomplish event/task\nscheduling and multitasking:\n\n\n\n\nTask and Scheduler. Each application consists of tasks or threads controlled by the operating system. The multitasking operation is implemented with a scheduler. The scheduler is in the kernel and manages the task execution at a specific time. The kernel can suspend and resume a task many times during lifecycle of the task execution.\n\n\nQueue. Queues are the primary forms of inter-task communications. \nIn most cases they are used as thread safe first-in-first-out (FIFO) buffers.\n\n\nSemaphore. Threads use semaphores to control the access to shared resources.\n\n\nSoftware Timer. A software timer allows a function to be invoked at a predefined time.\n\n\nThe timer callback functions are executed within the timer service task. It is essential to ensure the timer callback functions perform lightweight operations and return as quick as possible to avoid blocking the system resources.\n\n\nEvent Group (enabled after FreeRTOS version 8.0.0). An event group is a set of event bits. Individual event bits within an event group are referenced by a bit number. Event bits are used to indicate if an event has already occurred or not. Event groups can also be used to synchronize tasks.\n\n\nFor more information on FreeRTOS and its features, please refer to the official website.\n\n\n\n\n1.2. Heap service\n\n\nheap_4.c is used as the heap service on the SDK. More details can be found in the header file Source\\portable\n\n\n2. TCP/IP: lwIP\n\n\n\u251c\u2500\u2500\u2500lwip\n\u2502   \u251c\u2500\u2500\u2500contrib\n\u2502   \u2502   \u2514\u2500\u2500\u2500port\n\u2502   \u2502       \u2514\u2500\u2500\u2500FreeRTOS\n\u2502   \u2502           \u2514\u2500\u2500\u2500OpenRISC\n\u2502   \u2502               \u2514\u2500\u2500\u2500arch\n\u2502   \u251c\u2500\u2500\u2500doc\n\u2502   \u2514\u2500\u2500\u2500src\n\u2502       \u251c\u2500\u2500\u2500api\n\u2502       \u251c\u2500\u2500\u2500core\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2514\u2500\u2500\u2500snmp\n\u2502       \u251c\u2500\u2500\u2500include\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500lwip\n\u2502       \u2502   \u2514\u2500\u2500\u2500netif\n\u2502       \u2514\u2500\u2500\u2500netif\n\u2502           \u2514\u2500\u2500\u2500ppp\n\n\n\n\n\nTCP/IP (Transmission Control Protocol/Internet Protocol) is a communication internet protocol \nand can also be used in a private network, either an intranet or an extranet. It provides \nspecifications on how data should be packetized, addressed, transmitted, routed and received at the destination. The current IoT standard is moving towards IP communication and transporting data over various physical layers such as Wi-Fi, IEEE 802.15.4 and Bluetooth.\n\n\n\n\n2.1. Features\n\n\nlwIP is a widely used open source TCP/IP stack designed for embedded systems. \nIt includes the IP, ICMP, TCP, UDP, IGMP, ARP, AutoIP, DHCP, DNS and SNMP protocols.\n The SDK provides the following supported features for these protocols.\n\n\n\n\nIPv4\n (LWIP_IPV4).\n\n\nUDP (LWIP_UDP): User Datagram Protocol, the widely adopted connectionless transmission protocol.\n\n\nTCP (LWIP_TCP): Transmission Control Protocol, a widely used transport protocol providing reliable and in-order delivery.\n\n\nARP\n (LWIP_ARP).\n\n\nICMP\n (LWIP_ICMP).\n\n\nDHCP\n (LWIP_DHCP).\n\n\nDNS\n (LWIP_DNS).\n\n\nNETCONN\n (LWIP_NETCONN).\n\n\nSocket\n (LWIP_SOCKET).\n\n\n\n\n2.2. Memory usage\n\n\nThe MEM_SIZE parameter defines the size of the heap memory, PBUF_RAM, stores the sent and \nreceived data. If the application requires more data to send, the value of the parameter must be set higher.\nThe values of different control blocks are configurable in lwIP. For example, MEMP_NUM_NETDB\nsets the concurrent Domain Name Resolution connections. Below table lists the current configuration \nvalues of these blocks in the SDK. These pools are configured and allocated from a buffer reserved \nonly for the lwIP. The values are set to pass internal performance test and are expected to\nfulfill most common use cases. However, the number of configured control blocks could limit the maximum concurrent connections created by the network applications in the system, developers can configure these values for a specific use case.\n\n\n\n\n\n\n\n\nName\n\n\nCurrent_value\n\n\n\n\n\n\n\n\n\n\nMEMP_NUM_UDP_PCB\n\n\n4\n\n\n\n\n\n\nMEMP_NUM_TCP_PCB\n\n\n8\n\n\n\n\n\n\nMEMP_NUM_TCP_PCB_LISTEN\n\n\n16\n\n\n\n\n\n\nMEMP_NUM_TCP_SEB\n\n\n255\n\n\n\n\n\n\nMEMP_NUM_REASSDATA\n\n\n5\n\n\n\n\n\n\nMEMP_NUM_NETBUF\n\n\n2\n\n\n\n\n\n\nMEMP_NUM_NETCONN\n\n\n5\n\n\n\n\n\n\nMEMP_NUM_TCPIP_MSG_API\n\n\n8\n\n\n\n\n\n\nMEMP_NUM_TCPIP_MSG_INPKT\n\n\n8\n\n\n\n\n\n\nMEMP_NUM_SYS_TIMEOUT\n\n\n16\n\n\n\n\n\n\nMEMP_NUM_NETDB\n\n\n4\n\n\n\n\n\n\nMEMP_NUM_PBUF\n\n\n8\n\n\n\n\n\n\nPBUF_POOL_SIZE\n\n\n8\n\n\n\n\n\n\n\n\nThe required code size of lwIP is listed in Table. This information is gathered \nfrom an \nOpenRISC orpsocv2\n targeted configuration using the gcc -O2 optimization.\n The feature set is IPv4, TCP, UDP, DHCP client, ICMP, RAW, NETCONN and Sockets \n and DNS client. The footprint is shown below.\n\n\n\n\n\n\n\n\nStatic footprint\n\n\nROM(bytes)\n\n\nRAM(bytes)\n\n\n\n\n\n\n\n\n\n\nDebug rease\n\n\n68121\n\n\n59466\n\n\n\n\n\n\n\n\n3. SSL/TLS: mbed TLS\n\n\n\u251c\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2502   \u2514\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500library\n\u2502   \u2514\u2500\u2500\u2500port\n\n\n\n\n\nTransport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL) are cryptographic protocols designed to provide secure communication over the computer network. TLS and SSL use X.509 certificates and asymmetric cryptography to authenticate secure data communication and to negotiate the process with a symmetric session key that ensure message confidentiality.\n\n\n\n\nmbed TLS\n offers libraries including SSL/TLS cryptographic communication capabilities for (embedded) devices and applications that provide end-to-end communication protection to the upper layer application protocols such as web browsing, email, instant messaging and voice-over-IP (VoIP).\n\n\nStarting from the version 2.1.0, mbed TLS is released under Apache 2.0 License and enables developers to use mbed TLS in both open source and closed source projects. \n\n\n3.1. Features\n\n\nmbed TLS\n  is an open source and commercial SSL library licensed under ARM Limited. This library easily integrates with new and existing (embedded) devices and applications and provides the building blocks for secure communication, cryptography and key management. Both the client-side and the server-side APIs support current SSL and TLS standards: SSL version 3.0, TLS version 1.0, TLS version 1.1 and TLS version 1.2. The cryptographic algorithms enabled in the SDK include:\n\n\n\n\n1) Symmetric encryption algorithms: AES, Triple-DES (3DES), DES, ARC4.\n\n\n2) Modes of operations: Cipher Block Chaining Mode (CBC).\n\n\n3) Hash algorithms: MD5, SHA-1, and SHA-256.\n\n\n4) RSA/PKCS#1 v1.5.\n\n\n5) Random number generation: CTR_DRBG. \n\n\n\n\n3.2. Memory usage\n\n\n\n\n\n\n\n\nMemory(Kbytes)\n\n\nBasic\n\n\n\n\n\n\n\n\n\n\nROM\n\n\n78\n\n\n\n\n\n\nRAM\n\n\n8.7\n\n\n\n\n\n\nHEAP\n\n\n26\n\n\n\n\n\n\n\n\n4. HTTP (1.1) client: mbed HTTP Client\n\n\n\u251c\u2500\u2500\u2500httpclient\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u2514\u2500\u2500\u2500src\n\n\n\nThe Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web.\n\n\nHypertext is a structured text that uses logical links (hyperlinks) between nodes containing text. HTTP is the protocol to exchange or transfer hypertext.\n\n\nHTTP/1.1 is the most commonly used version of HTTP and was defined by \nRFC 2616\n in 1999.\n\n\n4.1. Features\n\n\nHTTPClient implements the client-side of HTTP/1.1. It provides base interfaces to send HTTP requests and receive HTTP responses from a resource identified by a URI. It also supports HTTPS (HTTP over SSL/TLS) to provide secure communication.\n\n\n4.2. Memory usage\n\n\nThe static footprint statistics for HTTP client are shown in Table, please note that the RAM size is 0 but it allocates the required buffer from system heap during the application execution.\n\n\n\n\n\n\n\n\n\n\nROM(Kb)\n\n\nRAM, static analysis (Kb)\n\n\n\n\n\n\n\n\n\n\nDebugging disabled\n\n\n3.5\n\n\n0\n\n\n\n\n\n\nDebugging Enabled\n\n\n7.1\n\n\n0\n\n\n\n\n\n\n\n\n5. HTTP/2 client: nghttp2\n\n\n\u251c\u2500\u2500\u2500nghttp2\n\u2502   \u251c\u2500\u2500\u2500lib\n\u2502   \u2502   \u2514\u2500\u2500\u2500includes\n\u2502   \u2502       \u2514\u2500\u2500\u2500nghttp2\n\u2502   \u2514\u2500\u2500\u2500port\n\u2502       \u2514\u2500\u2500\u2500include\n\n\n\nHTTP/2 is an alternative to HTTP1.1. HTTP methods, status codes and semantics are the same and it should be possible to use the same APIs as HTTP/1.x (possibly with some small additions) to represent the protocol.\n\n\nThe focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a website.\n\n\nThe basis of the work was SPDY, but HTTP/2 has evolved to take the community\u2019s input into account, incorporating several improvements in the process.\n\n\n5.1. Features\n\n\nThe framing layer of HTTP/2 is implemented as a reusable C library. On top of that, the SDK includes implementations of an HTTP/2 client, server, proxy, load test and bench marking tools for HTTP/2 and SPDY.\n\n\nAn HPACK encoder and decoder are available as public APIs.\n\n\nAn experimental high level C++ library is also available.\n\n\nIt only enables below features:\n\n\n\n\nThe C library of the HTTP/2 framing layer.\n\n\nHPACK encoder and decoder.\n\n\n\n\n5.2. Memory usage\n\n\nHTTP/2 is a new protocol and therefore it requires more \nresources in terms of code and heap size. See Table \nfor the required ROM/RAM and heap size.\n\n\n\n\n\n\n\n\n\n\nROM (bytes)\n\n\nRAM,static analysis(bytes)\n\n\nHeap size\n\n\n\n\n\n\n\n\n\n\nnghttp2\n\n\n60545\n\n\n1748\n\n\n80kB\n\n\n\n\n\n\n\n\nA. Video Demo over FPGA O-board\n\n\n-1. MQTT TLS on the FreeRTOS\n\n\n\n  \n\n\n\n\n\n-2. MQTT remote controller from the Cloud",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "OpenRISC is a CPU architecture developed by the OpenCores community. OR1200 is an open-source Verilog implementation of the CPU core, and ORPSoC (OpenRISC Reference Platform System on Chip) combines the OR1200 CPU with a set of peripherals.",
            "title": "Introduction"
        },
        {
            "location": "/#toolchain-on-the-linux",
            "text": "",
            "title": "Toolchain on the Linux"
        },
        {
            "location": "/#dependencies",
            "text": "sudo apt-get install libmpc-dev libgmp3-dev libmpfr-dev lzop libsdl1.2-dev xterm automake libtool",
            "title": "Dependencies"
        },
        {
            "location": "/#openrisc-gnu-tool-chain-precompiled-for-32-bit-linux",
            "text": "or1k-elf- toolchain built in April 2013 from github sources (150MB)  Extract this under /opt to create the directory or1k-toolchain.  Then run the following to add the executables to your $PATH:  echo \"# OpenRISC tool chain path\" >> ~/.bashrc\n\necho \"export PATH=$PATH:/opt/or1k-toolchain/bin\" >> ~/.bashrc",
            "title": "OpenRISC GNU tool chain precompiled for 32-bit Linux"
        },
        {
            "location": "/#0-stack",
            "text": "0.1 Stack structure  \u251c\u2500\u2500\u2500alexa\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500arch\n\u251c\u2500\u2500\u2500asio\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500audio_player\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500bear_ssl\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u251c\u2500\u2500\u2500src\n\u2502   \u2514\u2500\u2500\u2500tools\n\u251c\u2500\u2500\u2500cjson\n\u2502   \u2514\u2500\u2500\u2500inc\n\u251c\u2500\u2500\u2500common\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500dlna\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500drivers\n\u251c\u2500\u2500\u2500fifo\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500http\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500httpclient\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u2514\u2500\u2500\u2500src\n\u251c\u2500\u2500\u2500lwip\n\u2502   \u251c\u2500\u2500\u2500contrib\n\u2502   \u2502   \u2514\u2500\u2500\u2500port\n\u2502   \u2502       \u2514\u2500\u2500\u2500FreeRTOS\n\u2502   \u2502           \u2514\u2500\u2500\u2500OpenRISC\n\u2502   \u2502               \u2514\u2500\u2500\u2500arch\n\u2502   \u251c\u2500\u2500\u2500doc\n\u2502   \u2514\u2500\u2500\u2500src\n\u2502       \u251c\u2500\u2500\u2500api\n\u2502       \u251c\u2500\u2500\u2500core\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2514\u2500\u2500\u2500snmp\n\u2502       \u251c\u2500\u2500\u2500include\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500lwip\n\u2502       \u2502   \u2514\u2500\u2500\u2500netif\n\u2502       \u2514\u2500\u2500\u2500netif\n\u2502           \u2514\u2500\u2500\u2500ppp\n\u251c\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2502   \u2514\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500library\n\u2502   \u2514\u2500\u2500\u2500port\n\u251c\u2500\u2500\u2500mqtt\n\u2502   \u251c\u2500\u2500\u2500MQTTClient-C\n\u2502   \u2502   \u251c\u2500\u2500\u2500samples\n\u2502   \u2502   \u2502   \u2514\u2500\u2500\u2500linux\n\u2502   \u2502   \u2514\u2500\u2500\u2500src\n\u2502   \u2502       \n\u2502   \u2514\u2500\u2500\u2500MQTTPacket\n\u2502       \u251c\u2500\u2500\u2500samples\n\u2502       \u251c\u2500\u2500\u2500src\n\u2502       \u2514\u2500\u2500\u2500test\n\u251c\u2500\u2500\u2500multipart_parser\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500nghttp2\n\u2502   \u251c\u2500\u2500\u2500lib\n\u2502   \u2502   \u2514\u2500\u2500\u2500includes\n\u2502   \u2502       \u2514\u2500\u2500\u2500nghttp2\n\u2502   \u2514\u2500\u2500\u2500port\n\u2502       \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500nghttp_client\n\u2502   \u2514\u2500\u2500\u2500include\n\u251c\u2500\u2500\u2500sntp\n\u2502   \u2514\u2500\u2500\u2500inc\n\u251c\u2500\u2500\u2500Source  \n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2514\u2500\u2500\u2500portable\n\u2514\u2500\u2500\u2500url_parser\n    \u2514\u2500\u2500\u2500include",
            "title": "0. Stack"
        },
        {
            "location": "/#1-rtos-freertos",
            "text": "\u251c\u2500\u2500\u2500Source  \n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2514\u2500\u2500\u2500portable   FreeRTOS is a real-time OS that manages a multitasking and multiprocessing \nsystem environment. It has a scheduler to manage user created tasks.\nFreeRTOS provides APIs for users to control, \nsynchronize and communicate among various tasks.",
            "title": "1. RTOS: FreeRTOS"
        },
        {
            "location": "/#11-features",
            "text": "FreeRTOS supports the following five features to accomplish event/task\nscheduling and multitasking:   Task and Scheduler. Each application consists of tasks or threads controlled by the operating system. The multitasking operation is implemented with a scheduler. The scheduler is in the kernel and manages the task execution at a specific time. The kernel can suspend and resume a task many times during lifecycle of the task execution.  Queue. Queues are the primary forms of inter-task communications. \nIn most cases they are used as thread safe first-in-first-out (FIFO) buffers.  Semaphore. Threads use semaphores to control the access to shared resources.  Software Timer. A software timer allows a function to be invoked at a predefined time.  The timer callback functions are executed within the timer service task. It is essential to ensure the timer callback functions perform lightweight operations and return as quick as possible to avoid blocking the system resources.  Event Group (enabled after FreeRTOS version 8.0.0). An event group is a set of event bits. Individual event bits within an event group are referenced by a bit number. Event bits are used to indicate if an event has already occurred or not. Event groups can also be used to synchronize tasks.  For more information on FreeRTOS and its features, please refer to the official website.",
            "title": "1.1. Features"
        },
        {
            "location": "/#12-heap-service",
            "text": "heap_4.c is used as the heap service on the SDK. More details can be found in the header file Source\\portable",
            "title": "1.2. Heap service"
        },
        {
            "location": "/#2-tcpip-lwip",
            "text": "\u251c\u2500\u2500\u2500lwip\n\u2502   \u251c\u2500\u2500\u2500contrib\n\u2502   \u2502   \u2514\u2500\u2500\u2500port\n\u2502   \u2502       \u2514\u2500\u2500\u2500FreeRTOS\n\u2502   \u2502           \u2514\u2500\u2500\u2500OpenRISC\n\u2502   \u2502               \u2514\u2500\u2500\u2500arch\n\u2502   \u251c\u2500\u2500\u2500doc\n\u2502   \u2514\u2500\u2500\u2500src\n\u2502       \u251c\u2500\u2500\u2500api\n\u2502       \u251c\u2500\u2500\u2500core\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2514\u2500\u2500\u2500snmp\n\u2502       \u251c\u2500\u2500\u2500include\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv4\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500ipv6\n\u2502       \u2502   \u2502   \u2514\u2500\u2500\u2500lwip\n\u2502       \u2502   \u251c\u2500\u2500\u2500lwip\n\u2502       \u2502   \u2514\u2500\u2500\u2500netif\n\u2502       \u2514\u2500\u2500\u2500netif\n\u2502           \u2514\u2500\u2500\u2500ppp   TCP/IP (Transmission Control Protocol/Internet Protocol) is a communication internet protocol \nand can also be used in a private network, either an intranet or an extranet. It provides \nspecifications on how data should be packetized, addressed, transmitted, routed and received at the destination. The current IoT standard is moving towards IP communication and transporting data over various physical layers such as Wi-Fi, IEEE 802.15.4 and Bluetooth.",
            "title": "2. TCP/IP: lwIP"
        },
        {
            "location": "/#21-features",
            "text": "lwIP is a widely used open source TCP/IP stack designed for embedded systems. \nIt includes the IP, ICMP, TCP, UDP, IGMP, ARP, AutoIP, DHCP, DNS and SNMP protocols.\n The SDK provides the following supported features for these protocols.   IPv4  (LWIP_IPV4).  UDP (LWIP_UDP): User Datagram Protocol, the widely adopted connectionless transmission protocol.  TCP (LWIP_TCP): Transmission Control Protocol, a widely used transport protocol providing reliable and in-order delivery.  ARP  (LWIP_ARP).  ICMP  (LWIP_ICMP).  DHCP  (LWIP_DHCP).  DNS  (LWIP_DNS).  NETCONN  (LWIP_NETCONN).  Socket  (LWIP_SOCKET).",
            "title": "2.1. Features"
        },
        {
            "location": "/#22-memory-usage",
            "text": "The MEM_SIZE parameter defines the size of the heap memory, PBUF_RAM, stores the sent and \nreceived data. If the application requires more data to send, the value of the parameter must be set higher.\nThe values of different control blocks are configurable in lwIP. For example, MEMP_NUM_NETDB\nsets the concurrent Domain Name Resolution connections. Below table lists the current configuration \nvalues of these blocks in the SDK. These pools are configured and allocated from a buffer reserved \nonly for the lwIP. The values are set to pass internal performance test and are expected to\nfulfill most common use cases. However, the number of configured control blocks could limit the maximum concurrent connections created by the network applications in the system, developers can configure these values for a specific use case.     Name  Current_value      MEMP_NUM_UDP_PCB  4    MEMP_NUM_TCP_PCB  8    MEMP_NUM_TCP_PCB_LISTEN  16    MEMP_NUM_TCP_SEB  255    MEMP_NUM_REASSDATA  5    MEMP_NUM_NETBUF  2    MEMP_NUM_NETCONN  5    MEMP_NUM_TCPIP_MSG_API  8    MEMP_NUM_TCPIP_MSG_INPKT  8    MEMP_NUM_SYS_TIMEOUT  16    MEMP_NUM_NETDB  4    MEMP_NUM_PBUF  8    PBUF_POOL_SIZE  8     The required code size of lwIP is listed in Table. This information is gathered \nfrom an  OpenRISC orpsocv2  targeted configuration using the gcc -O2 optimization.\n The feature set is IPv4, TCP, UDP, DHCP client, ICMP, RAW, NETCONN and Sockets \n and DNS client. The footprint is shown below.     Static footprint  ROM(bytes)  RAM(bytes)      Debug rease  68121  59466",
            "title": "2.2. Memory usage"
        },
        {
            "location": "/#3-ssltls-mbed-tls",
            "text": "\u251c\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500include\n\u2502   \u2502   \u2514\u2500\u2500\u2500mbedtls\n\u2502   \u251c\u2500\u2500\u2500library\n\u2502   \u2514\u2500\u2500\u2500port   Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL) are cryptographic protocols designed to provide secure communication over the computer network. TLS and SSL use X.509 certificates and asymmetric cryptography to authenticate secure data communication and to negotiate the process with a symmetric session key that ensure message confidentiality.   mbed TLS  offers libraries including SSL/TLS cryptographic communication capabilities for (embedded) devices and applications that provide end-to-end communication protection to the upper layer application protocols such as web browsing, email, instant messaging and voice-over-IP (VoIP).  Starting from the version 2.1.0, mbed TLS is released under Apache 2.0 License and enables developers to use mbed TLS in both open source and closed source projects.",
            "title": "3. SSL/TLS: mbed TLS"
        },
        {
            "location": "/#31-features",
            "text": "mbed TLS   is an open source and commercial SSL library licensed under ARM Limited. This library easily integrates with new and existing (embedded) devices and applications and provides the building blocks for secure communication, cryptography and key management. Both the client-side and the server-side APIs support current SSL and TLS standards: SSL version 3.0, TLS version 1.0, TLS version 1.1 and TLS version 1.2. The cryptographic algorithms enabled in the SDK include:   1) Symmetric encryption algorithms: AES, Triple-DES (3DES), DES, ARC4.  2) Modes of operations: Cipher Block Chaining Mode (CBC).  3) Hash algorithms: MD5, SHA-1, and SHA-256.  4) RSA/PKCS#1 v1.5.  5) Random number generation: CTR_DRBG.",
            "title": "3.1. Features"
        },
        {
            "location": "/#32-memory-usage",
            "text": "Memory(Kbytes)  Basic      ROM  78    RAM  8.7    HEAP  26",
            "title": "3.2. Memory usage"
        },
        {
            "location": "/#4-http-11-client-mbed-http-client",
            "text": "\u251c\u2500\u2500\u2500httpclient\n\u2502   \u251c\u2500\u2500\u2500inc\n\u2502   \u2514\u2500\u2500\u2500src  The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web.  Hypertext is a structured text that uses logical links (hyperlinks) between nodes containing text. HTTP is the protocol to exchange or transfer hypertext.  HTTP/1.1 is the most commonly used version of HTTP and was defined by  RFC 2616  in 1999.",
            "title": "4. HTTP (1.1) client: mbed HTTP Client"
        },
        {
            "location": "/#41-features",
            "text": "HTTPClient implements the client-side of HTTP/1.1. It provides base interfaces to send HTTP requests and receive HTTP responses from a resource identified by a URI. It also supports HTTPS (HTTP over SSL/TLS) to provide secure communication.",
            "title": "4.1. Features"
        },
        {
            "location": "/#42-memory-usage",
            "text": "The static footprint statistics for HTTP client are shown in Table, please note that the RAM size is 0 but it allocates the required buffer from system heap during the application execution.      ROM(Kb)  RAM, static analysis (Kb)      Debugging disabled  3.5  0    Debugging Enabled  7.1  0",
            "title": "4.2. Memory usage"
        },
        {
            "location": "/#5-http2-client-nghttp2",
            "text": "\u251c\u2500\u2500\u2500nghttp2\n\u2502   \u251c\u2500\u2500\u2500lib\n\u2502   \u2502   \u2514\u2500\u2500\u2500includes\n\u2502   \u2502       \u2514\u2500\u2500\u2500nghttp2\n\u2502   \u2514\u2500\u2500\u2500port\n\u2502       \u2514\u2500\u2500\u2500include  HTTP/2 is an alternative to HTTP1.1. HTTP methods, status codes and semantics are the same and it should be possible to use the same APIs as HTTP/1.x (possibly with some small additions) to represent the protocol.  The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a website.  The basis of the work was SPDY, but HTTP/2 has evolved to take the community\u2019s input into account, incorporating several improvements in the process.",
            "title": "5. HTTP/2 client: nghttp2"
        },
        {
            "location": "/#51-features",
            "text": "The framing layer of HTTP/2 is implemented as a reusable C library. On top of that, the SDK includes implementations of an HTTP/2 client, server, proxy, load test and bench marking tools for HTTP/2 and SPDY.  An HPACK encoder and decoder are available as public APIs.  An experimental high level C++ library is also available.  It only enables below features:   The C library of the HTTP/2 framing layer.  HPACK encoder and decoder.",
            "title": "5.1. Features"
        },
        {
            "location": "/#52-memory-usage",
            "text": "HTTP/2 is a new protocol and therefore it requires more \nresources in terms of code and heap size. See Table \nfor the required ROM/RAM and heap size.      ROM (bytes)  RAM,static analysis(bytes)  Heap size      nghttp2  60545  1748  80kB",
            "title": "5.2. Memory usage"
        },
        {
            "location": "/#a-video-demo-over-fpga-o-board",
            "text": "-1. MQTT TLS on the FreeRTOS  \n     -2. MQTT remote controller from the Cloud",
            "title": "A. Video Demo over FPGA O-board"
        },
        {
            "location": "/code/",
            "text": "0.CPU type ( Arch/cpu.h )\n\n\n#define BYTE_ORDER BIG_ENDIAN\n\n\n\n1.Linker Scripts\n\n\nMEMORY\n{\n    /* Put all sections expect data, rodata into ram2   */\n    /* On ORSoC dev board devices, for pages 132-134 ( 256Bytes pages)  */\n\n    vectors : ORIGIN = 0x00000000, LENGTH = 0x00002000\n    sdram (rwx)    : ORIGIN = 0x00002000, LENGTH = 0x13500\n    sdram2 (rwx)    : ORIGIN = 0x13500, LENGTH = 0x02000000 \n}\n\nheap_size = 10*1024;\nSECTIONS\n{\n    .vectors :\n    {\n        _vec_start = .;\n        *(.vectors)\n        _vec_end = .;\n    } > vectors\n\n\n    .text  :\n    {\n        . = ALIGN(4);\n        *(.text)\n        *(.text*)\n        . = ALIGN(4);\n    } > sdram2\n\n    .data  :\n    {\n        . = ALIGN(4);\n        _dst_beg = .;\n        *(.data)\n        *(.data*)\n        _dst_end = .;\n        . = ALIGN(4);\n    } > sdram\n\n    .rodata :\n    {\n        . = ALIGN(4);\n        *(.rodata)\n        *(.rodata.*)\n        . = ALIGN(4);\n    } > sdram\n\n    .sbss  :\n    {\n        . = ALIGN(4);\n        _sbss_beg = .;\n        *(.bss)\n        *(.bss*)\n        _sbss_end = .;\n        . = ALIGN(4);\n    } > sdram2\n\n    .sdata : {\n        _gp = . + 0x800;\n        *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata*)\n        *(.sdata .sdata.* .gnu.linkonce.s.*)\n     }  > sdram2\n\n    .bss  :\n    {\n        . = ALIGN(4);\n        _bss_beg = .;\n        *(.bss)\n        *(.bss*)\n        *(COMMON)\n        _bss_end = .;\n        . = ALIGN(4);\n    } > sdram2\n\n    .heap :\n    {\n        . = ALIGN(4);\n        __heap_start = .;\n        . = . +heap_size;\n        __heap_end = .;\n    } > sdram2\n\n\n    .stack :\n    {\n        . = ALIGN(4);\n        *(.stack)\n        _stack_top = .;\n        . = ALIGN(4);\n    } >sdram2\n\n    PROVIDE(_stack_top = 0x02000000 );\n}\n\n\n\n2.FreeRTOSConfig.h\n\n\n#include \"board.h\"\n\n#define configUSE_PREEMPTION            1\n#define configUSE_IDLE_HOOK             0\n#define configUSE_TICK_HOOK             0\n#define configCPU_CLOCK_HZ              ( ( unsigned long ) SYS_CLK )\n#define configTICK_RATE_HZ              ( ( TickType_t ) 1000 )\n#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 100)\n#define configTOTAL_HEAP_SIZE           ( ( size_t ) 49*1024 )\n\n\n\n3.Port.c\n\n\n/*\n * Initialise the stack of a task to look exactly as if a call to\n * portSAVE_CONTEXT had been called. Context layout is described in\n * portmarco.h\n *\n * See header file for description.\n */\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack,\n                                       TaskFunction_t pxCode,\n                                       void *pvParameters )\n{\n    unsigned portLONG uTaskSR = mfspr(SPR_SR);\n\n    // Supervisor mode\n    uTaskSR |= SPR_SR_SM;\n    // Tick interrupt enable, All External interupt enable\n    uTaskSR |= (SPR_SR_TEE | SPR_SR_IEE);\n\n    // allocate redzone\n    pxTopOfStack -= REDZONE_SIZE/4;\n\n    /* Setup the initial stack of the task.  The stack is set exactly as\n    expected by the portRESTORE_CONTEXT() macro. */\n    *(--pxTopOfStack) = ( StackType_t )pxCode;         // SPR_EPCR_BASE(0)\n    *(--pxTopOfStack) = ( StackType_t )uTaskSR;        // SPR_ESR_BASE(0)\n\n    *(--pxTopOfStack) = ( StackType_t )0x00000031;     // r31\n    *(--pxTopOfStack) = ( StackType_t )0x00000030;     // r30\n    *(--pxTopOfStack) = ( StackType_t )0x00000029;     // r29\n    *(--pxTopOfStack) = ( StackType_t )0x00000028;     // r28\n    *(--pxTopOfStack) = ( StackType_t )0x00000027;     // r27\n    *(--pxTopOfStack) = ( StackType_t )0x00000026;     // r26\n    *(--pxTopOfStack) = ( StackType_t )0x00000025;     // r25\n    *(--pxTopOfStack) = ( StackType_t )0x00000024;     // r24\n    *(--pxTopOfStack) = ( StackType_t )0x00000023;     // r23\n    *(--pxTopOfStack) = ( StackType_t )0x00000022;     // r22\n    *(--pxTopOfStack) = ( StackType_t )0x00000021;     // r21\n    *(--pxTopOfStack) = ( StackType_t )0x00000020;     // r20\n    *(--pxTopOfStack) = ( StackType_t )0x00000019;     // r19\n    *(--pxTopOfStack) = ( StackType_t )0x00000018;     // r18\n    *(--pxTopOfStack) = ( StackType_t )0x00000017;     // r17\n    *(--pxTopOfStack) = ( StackType_t )0x00000016;     // r16\n    *(--pxTopOfStack) = ( StackType_t )0x00000015;     // r15\n    *(--pxTopOfStack) = ( StackType_t )0x00000014;     // r14\n    *(--pxTopOfStack) = ( StackType_t )0x00000013;     // r13\n    *(--pxTopOfStack) = ( StackType_t )0x00000012;     // r12\n    *(--pxTopOfStack) = ( StackType_t )0x00000011;     // r11\n    *(--pxTopOfStack) = ( StackType_t )0x00000010;     // r10\n    *(--pxTopOfStack) = ( StackType_t )0x00000008;     // r8\n    *(--pxTopOfStack) = ( StackType_t )0x00000007;     // r7\n    *(--pxTopOfStack) = ( StackType_t )0x00000006;     // r6\n    *(--pxTopOfStack) = ( StackType_t )0x00000005;     // r5\n    *(--pxTopOfStack) = ( StackType_t )0x00000004;     // r4\n    *(--pxTopOfStack) = ( StackType_t )pvParameters;   // task argument\n    *(--pxTopOfStack) = ( StackType_t )0x00000002;     // r2\n    *(--pxTopOfStack) = ( StackType_t )pxCode;         // PC\n\n    return pxTopOfStack;\n}\n\nBaseType_t xPortStartScheduler( void )\n{\n    if(setjmp((void *)jmpbuf) == 0) {\n        /* Start the timer that generates the tick ISR.\n     * Interrupts are disabled here already. */\n        prvSetupTimerInterrupt();\n\n        /* Start the first task. */\n        asm volatile (\n        \" .global   pxCurrentTCB    \\n\\t\"\n        /*   restore stack pointer          */\n        \"   l.movhi r3, hi(pxCurrentTCB)        \\n\\t\"\n        \"   l.ori   r3, r3, lo(pxCurrentTCB)    \\n\\t\"\n        \"   l.lwz   r3, 0x0(r3)     \\n\\t\"\n        \"   l.lwz   r1, 0x0(r3)     \\n\\t\"\n        /*   restore context                */\n        \"   l.lwz   r9,  0x00(r1)   \\n\\t\"\n        \"   l.lwz   r2,  0x04(r1)   \\n\\t\"\n        \"   l.lwz   r6,  0x14(r1)   \\n\\t\"\n        \"   l.lwz   r7,  0x18(r1)   \\n\\t\"\n        \"   l.lwz   r8,  0x1C(r1)   \\n\\t\"\n        \"   l.lwz   r10, 0x20(r1)   \\n\\t\"\n        \"   l.lwz   r11, 0x24(r1)   \\n\\t\"\n        \"   l.lwz   r12, 0x28(r1)   \\n\\t\"\n        \"   l.lwz   r13, 0x2C(r1)   \\n\\t\"\n        \"   l.lwz   r14, 0x30(r1)   \\n\\t\"\n        \"   l.lwz   r15, 0x34(r1)   \\n\\t\"\n        \"   l.lwz   r16, 0x38(r1)   \\n\\t\"\n        \"   l.lwz   r17, 0x3C(r1)   \\n\\t\"\n        \"   l.lwz   r18, 0x40(r1)   \\n\\t\"\n        \"   l.lwz   r19, 0x44(r1)   \\n\\t\"\n        \"   l.lwz   r20, 0x48(r1)   \\n\\t\"\n        \"   l.lwz   r21, 0x4C(r1)   \\n\\t\"\n        \"   l.lwz   r22, 0x50(r1)   \\n\\t\"\n        \"   l.lwz   r23, 0x54(r1)   \\n\\t\"\n        \"   l.lwz   r24, 0x58(r1)   \\n\\t\"\n        \"   l.lwz   r25, 0x5C(r1)   \\n\\t\"\n        \"   l.lwz   r26, 0x60(r1)   \\n\\t\"\n        \"   l.lwz   r27, 0x64(r1)   \\n\\t\"\n        \"   l.lwz   r28, 0x68(r1)   \\n\\t\"\n        \"   l.lwz   r29, 0x6C(r1)   \\n\\t\"\n        \"   l.lwz   r30, 0x70(r1)   \\n\\t\"\n        \"   l.lwz   r31, 0x74(r1)   \\n\\t\"\n        /*  restore SPR_ESR_BASE(0), SPR_EPCR_BASE(0) */\n        \"   l.lwz   r3,  0x78(r1)   \\n\\t\"\n        \"   l.lwz   r4,  0x7C(r1)   \\n\\t\"\n        \"   l.mtspr r0,  r3, %1     \\n\\t\"\n        \"   l.mtspr r0,  r4, %2     \\n\\t\"\n        /*   restore clobber register     */\n        \"   l.lwz   r3,  0x08(r1)   \\n\\t\"\n        \"   l.lwz   r4,  0x0C(r1)   \\n\\t\"\n        \"   l.lwz   r5,  0x10(r1)   \\n\\t\"\n        \"   l.addi  r1,  r1, %0     \\n\\t\"\n        \"   l.rfe                   \\n\\t\"\n        \"   l.nop                   \\n\\t\"\n        :\n        :   \"n\"(STACKFRAME_SIZE),\n            \"n\"(SPR_ESR_BASE),\n            \"n\"(SPR_EPCR_BASE)\n        );\n\n        /* Should not get here! */\n    } else {\n        /* Retrun by vPortEndScheduler */\n    }\n\n    return 0;\n}\n\n\n\n4.Mbedtls Configuration\n\n\n#define MBEDTLS_PLATFORM_CALLOC_MACRO mbedtls_calloc\n#define MBEDTLS_PLATFORM_FREE_MACRO mbedtls_free\n/*\n * Save RAM at the expense of interoperability: do this only if you control\n * both ends of the connection!  (See comments in \"mbedtls/ssl.h\".)\n * The optimal size here depends on the typical size of records.\n */\n#define MBEDTLS_SSL_MAX_CONTENT_LEN             (5*1024)",
            "title": "Code Review"
        },
        {
            "location": "/code/#0cpu-type-archcpuh",
            "text": "#define BYTE_ORDER BIG_ENDIAN",
            "title": "0.CPU type ( Arch/cpu.h )"
        },
        {
            "location": "/code/#1linker-scripts",
            "text": "MEMORY\n{\n    /* Put all sections expect data, rodata into ram2   */\n    /* On ORSoC dev board devices, for pages 132-134 ( 256Bytes pages)  */\n\n    vectors : ORIGIN = 0x00000000, LENGTH = 0x00002000\n    sdram (rwx)    : ORIGIN = 0x00002000, LENGTH = 0x13500\n    sdram2 (rwx)    : ORIGIN = 0x13500, LENGTH = 0x02000000 \n}\n\nheap_size = 10*1024;\nSECTIONS\n{\n    .vectors :\n    {\n        _vec_start = .;\n        *(.vectors)\n        _vec_end = .;\n    } > vectors\n\n\n    .text  :\n    {\n        . = ALIGN(4);\n        *(.text)\n        *(.text*)\n        . = ALIGN(4);\n    } > sdram2\n\n    .data  :\n    {\n        . = ALIGN(4);\n        _dst_beg = .;\n        *(.data)\n        *(.data*)\n        _dst_end = .;\n        . = ALIGN(4);\n    } > sdram\n\n    .rodata :\n    {\n        . = ALIGN(4);\n        *(.rodata)\n        *(.rodata.*)\n        . = ALIGN(4);\n    } > sdram\n\n    .sbss  :\n    {\n        . = ALIGN(4);\n        _sbss_beg = .;\n        *(.bss)\n        *(.bss*)\n        _sbss_end = .;\n        . = ALIGN(4);\n    } > sdram2\n\n    .sdata : {\n        _gp = . + 0x800;\n        *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata*)\n        *(.sdata .sdata.* .gnu.linkonce.s.*)\n     }  > sdram2\n\n    .bss  :\n    {\n        . = ALIGN(4);\n        _bss_beg = .;\n        *(.bss)\n        *(.bss*)\n        *(COMMON)\n        _bss_end = .;\n        . = ALIGN(4);\n    } > sdram2\n\n    .heap :\n    {\n        . = ALIGN(4);\n        __heap_start = .;\n        . = . +heap_size;\n        __heap_end = .;\n    } > sdram2\n\n\n    .stack :\n    {\n        . = ALIGN(4);\n        *(.stack)\n        _stack_top = .;\n        . = ALIGN(4);\n    } >sdram2\n\n    PROVIDE(_stack_top = 0x02000000 );\n}",
            "title": "1.Linker Scripts"
        },
        {
            "location": "/code/#2freertosconfigh",
            "text": "#include \"board.h\"\n\n#define configUSE_PREEMPTION            1\n#define configUSE_IDLE_HOOK             0\n#define configUSE_TICK_HOOK             0\n#define configCPU_CLOCK_HZ              ( ( unsigned long ) SYS_CLK )\n#define configTICK_RATE_HZ              ( ( TickType_t ) 1000 )\n#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 100)\n#define configTOTAL_HEAP_SIZE           ( ( size_t ) 49*1024 )",
            "title": "2.FreeRTOSConfig.h"
        },
        {
            "location": "/code/#3portc",
            "text": "/*\n * Initialise the stack of a task to look exactly as if a call to\n * portSAVE_CONTEXT had been called. Context layout is described in\n * portmarco.h\n *\n * See header file for description.\n */\nStackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack,\n                                       TaskFunction_t pxCode,\n                                       void *pvParameters )\n{\n    unsigned portLONG uTaskSR = mfspr(SPR_SR);\n\n    // Supervisor mode\n    uTaskSR |= SPR_SR_SM;\n    // Tick interrupt enable, All External interupt enable\n    uTaskSR |= (SPR_SR_TEE | SPR_SR_IEE);\n\n    // allocate redzone\n    pxTopOfStack -= REDZONE_SIZE/4;\n\n    /* Setup the initial stack of the task.  The stack is set exactly as\n    expected by the portRESTORE_CONTEXT() macro. */\n    *(--pxTopOfStack) = ( StackType_t )pxCode;         // SPR_EPCR_BASE(0)\n    *(--pxTopOfStack) = ( StackType_t )uTaskSR;        // SPR_ESR_BASE(0)\n\n    *(--pxTopOfStack) = ( StackType_t )0x00000031;     // r31\n    *(--pxTopOfStack) = ( StackType_t )0x00000030;     // r30\n    *(--pxTopOfStack) = ( StackType_t )0x00000029;     // r29\n    *(--pxTopOfStack) = ( StackType_t )0x00000028;     // r28\n    *(--pxTopOfStack) = ( StackType_t )0x00000027;     // r27\n    *(--pxTopOfStack) = ( StackType_t )0x00000026;     // r26\n    *(--pxTopOfStack) = ( StackType_t )0x00000025;     // r25\n    *(--pxTopOfStack) = ( StackType_t )0x00000024;     // r24\n    *(--pxTopOfStack) = ( StackType_t )0x00000023;     // r23\n    *(--pxTopOfStack) = ( StackType_t )0x00000022;     // r22\n    *(--pxTopOfStack) = ( StackType_t )0x00000021;     // r21\n    *(--pxTopOfStack) = ( StackType_t )0x00000020;     // r20\n    *(--pxTopOfStack) = ( StackType_t )0x00000019;     // r19\n    *(--pxTopOfStack) = ( StackType_t )0x00000018;     // r18\n    *(--pxTopOfStack) = ( StackType_t )0x00000017;     // r17\n    *(--pxTopOfStack) = ( StackType_t )0x00000016;     // r16\n    *(--pxTopOfStack) = ( StackType_t )0x00000015;     // r15\n    *(--pxTopOfStack) = ( StackType_t )0x00000014;     // r14\n    *(--pxTopOfStack) = ( StackType_t )0x00000013;     // r13\n    *(--pxTopOfStack) = ( StackType_t )0x00000012;     // r12\n    *(--pxTopOfStack) = ( StackType_t )0x00000011;     // r11\n    *(--pxTopOfStack) = ( StackType_t )0x00000010;     // r10\n    *(--pxTopOfStack) = ( StackType_t )0x00000008;     // r8\n    *(--pxTopOfStack) = ( StackType_t )0x00000007;     // r7\n    *(--pxTopOfStack) = ( StackType_t )0x00000006;     // r6\n    *(--pxTopOfStack) = ( StackType_t )0x00000005;     // r5\n    *(--pxTopOfStack) = ( StackType_t )0x00000004;     // r4\n    *(--pxTopOfStack) = ( StackType_t )pvParameters;   // task argument\n    *(--pxTopOfStack) = ( StackType_t )0x00000002;     // r2\n    *(--pxTopOfStack) = ( StackType_t )pxCode;         // PC\n\n    return pxTopOfStack;\n}\n\nBaseType_t xPortStartScheduler( void )\n{\n    if(setjmp((void *)jmpbuf) == 0) {\n        /* Start the timer that generates the tick ISR.\n     * Interrupts are disabled here already. */\n        prvSetupTimerInterrupt();\n\n        /* Start the first task. */\n        asm volatile (\n        \" .global   pxCurrentTCB    \\n\\t\"\n        /*   restore stack pointer          */\n        \"   l.movhi r3, hi(pxCurrentTCB)        \\n\\t\"\n        \"   l.ori   r3, r3, lo(pxCurrentTCB)    \\n\\t\"\n        \"   l.lwz   r3, 0x0(r3)     \\n\\t\"\n        \"   l.lwz   r1, 0x0(r3)     \\n\\t\"\n        /*   restore context                */\n        \"   l.lwz   r9,  0x00(r1)   \\n\\t\"\n        \"   l.lwz   r2,  0x04(r1)   \\n\\t\"\n        \"   l.lwz   r6,  0x14(r1)   \\n\\t\"\n        \"   l.lwz   r7,  0x18(r1)   \\n\\t\"\n        \"   l.lwz   r8,  0x1C(r1)   \\n\\t\"\n        \"   l.lwz   r10, 0x20(r1)   \\n\\t\"\n        \"   l.lwz   r11, 0x24(r1)   \\n\\t\"\n        \"   l.lwz   r12, 0x28(r1)   \\n\\t\"\n        \"   l.lwz   r13, 0x2C(r1)   \\n\\t\"\n        \"   l.lwz   r14, 0x30(r1)   \\n\\t\"\n        \"   l.lwz   r15, 0x34(r1)   \\n\\t\"\n        \"   l.lwz   r16, 0x38(r1)   \\n\\t\"\n        \"   l.lwz   r17, 0x3C(r1)   \\n\\t\"\n        \"   l.lwz   r18, 0x40(r1)   \\n\\t\"\n        \"   l.lwz   r19, 0x44(r1)   \\n\\t\"\n        \"   l.lwz   r20, 0x48(r1)   \\n\\t\"\n        \"   l.lwz   r21, 0x4C(r1)   \\n\\t\"\n        \"   l.lwz   r22, 0x50(r1)   \\n\\t\"\n        \"   l.lwz   r23, 0x54(r1)   \\n\\t\"\n        \"   l.lwz   r24, 0x58(r1)   \\n\\t\"\n        \"   l.lwz   r25, 0x5C(r1)   \\n\\t\"\n        \"   l.lwz   r26, 0x60(r1)   \\n\\t\"\n        \"   l.lwz   r27, 0x64(r1)   \\n\\t\"\n        \"   l.lwz   r28, 0x68(r1)   \\n\\t\"\n        \"   l.lwz   r29, 0x6C(r1)   \\n\\t\"\n        \"   l.lwz   r30, 0x70(r1)   \\n\\t\"\n        \"   l.lwz   r31, 0x74(r1)   \\n\\t\"\n        /*  restore SPR_ESR_BASE(0), SPR_EPCR_BASE(0) */\n        \"   l.lwz   r3,  0x78(r1)   \\n\\t\"\n        \"   l.lwz   r4,  0x7C(r1)   \\n\\t\"\n        \"   l.mtspr r0,  r3, %1     \\n\\t\"\n        \"   l.mtspr r0,  r4, %2     \\n\\t\"\n        /*   restore clobber register     */\n        \"   l.lwz   r3,  0x08(r1)   \\n\\t\"\n        \"   l.lwz   r4,  0x0C(r1)   \\n\\t\"\n        \"   l.lwz   r5,  0x10(r1)   \\n\\t\"\n        \"   l.addi  r1,  r1, %0     \\n\\t\"\n        \"   l.rfe                   \\n\\t\"\n        \"   l.nop                   \\n\\t\"\n        :\n        :   \"n\"(STACKFRAME_SIZE),\n            \"n\"(SPR_ESR_BASE),\n            \"n\"(SPR_EPCR_BASE)\n        );\n\n        /* Should not get here! */\n    } else {\n        /* Retrun by vPortEndScheduler */\n    }\n\n    return 0;\n}",
            "title": "3.Port.c"
        },
        {
            "location": "/code/#4mbedtls-configuration",
            "text": "#define MBEDTLS_PLATFORM_CALLOC_MACRO mbedtls_calloc\n#define MBEDTLS_PLATFORM_FREE_MACRO mbedtls_free\n/*\n * Save RAM at the expense of interoperability: do this only if you control\n * both ends of the connection!  (See comments in \"mbedtls/ssl.h\".)\n * The optimal size here depends on the typical size of records.\n */\n#define MBEDTLS_SSL_MAX_CONTENT_LEN             (5*1024)",
            "title": "4.Mbedtls Configuration"
        }
    ]
}